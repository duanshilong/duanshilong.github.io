<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dsl-blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-26T15:22:07.664Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hubery</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速认识promise</title>
    <link href="http://yoursite.com/2019/02/26/%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8promise/"/>
    <id>http://yoursite.com/2019/02/26/快速使用promise/</id>
    <published>2019-02-26T14:45:55.691Z</published>
    <updated>2019-02-26T15:22:07.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、为什么要用Promise？（es6）"><a href="#1、为什么要用Promise？（es6）" class="headerlink" title="1、为什么要用Promise？（es6）"></a>1、为什么要用Promise？（es6）</h2><p>当我们使用js的异步调用时通常喜欢使用回调函数，这样代码便于理解。但是当回调嵌套的时候会造成代码混乱，不好梳理，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function(arg1,</span><br><span class="line">    function()&#123;</span><br><span class="line">        function(arg2,</span><br><span class="line">            function()&#123; </span><br><span class="line">                function(arg3,</span><br><span class="line">                    fucntion()&#123; </span><br><span class="line">                            ...... &#125;</span><br><span class="line">                    ) </span><br><span class="line">                &#125;)</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure></p><p>像上面代码，无穷嵌套会造成代码混乱。而Promise的最大好处就是避免‘无穷的回调噩梦’，<br>上述代码用promise处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise(function(resolve,reject&#123;&#125;)</span><br><span class="line">.then(function(data)&#123;&#125;)</span><br><span class="line">.then(function()&#123;&#125;)</span><br></pre></td></tr></table></figure><p>这是Promise的基本用法<br>Promise接收一个回调函数，回调函数接收两个参数，resolve（promise的状态从pending变为了fulfiled,成功时调用）、reject（promise的状态从pending变为了rejected,失败时调用），这两个都是函数，表示成功和失败的处理函数。then中接收的是上一次回调返回的结果</p><h2 id="2、promise-prototype-then"><a href="#2、promise-prototype-then" class="headerlink" title="2、promise.prototype.then()"></a>2、promise.prototype.then()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve,reject)&#123;</span><br><span class="line">console.log(&quot;promise&quot;);</span><br><span class="line">resolve();</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">console.log(&quot;setTimeout&quot;);</span><br><span class="line">&#125;,0)</span><br><span class="line">promise.then(function()&#123;</span><br><span class="line">console.log(&quot;resolved&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&quot;hi&quot;);</span><br><span class="line">//promise hi resolved setTimeout</span><br></pre></td></tr></table></figure><p>promise是创建之后立即执行，then方法指定的脚本在当前所有的同步任务完成之后再执行，setTimeout是在下一轮“时间循环”开始时执行，then在本轮时间循环结束时还行</p><h2 id="3、promise-prototype-catch"><a href="#3、promise-prototype-catch" class="headerlink" title="3、promise.prototype.catch()"></a>3、promise.prototype.catch()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function(resolve,reject)&#123;</span><br><span class="line">reject();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(function()&#123;</span><br><span class="line">console.log(&quot;resolved&quot;);</span><br><span class="line">&#125;).catch(function()&#123;</span><br><span class="line">console.log(&quot;catch the reject&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">输出 catch the reject</span><br></pre></td></tr></table></figure><h2 id="4、promise的方法有："><a href="#4、promise的方法有：" class="headerlink" title="4、promise的方法有："></a>4、promise的方法有：</h2><p>promise.resolve()<br>promise.reject()<br>promise.all()<br>promise.race()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、为什么要用Promise？（es6）&quot;&gt;&lt;a href=&quot;#1、为什么要用Promise？（es6）&quot; class=&quot;headerlink&quot; title=&quot;1、为什么要用Promise？（es6）&quot;&gt;&lt;/a&gt;1、为什么要用Promise？（es6）&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
</feed>

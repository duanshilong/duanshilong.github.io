{"meta":{"title":"dsl-blog","subtitle":null,"description":null,"author":"Hubery","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"vue源码之双向绑定","slug":"vue源码之双向绑定原理","date":"2019-03-02T04:10:47.875Z","updated":"2019-03-02T04:36:54.741Z","comments":true,"path":"2019/03/02/vue源码之双向绑定原理/","link":"","permalink":"http://yoursite.com/2019/03/02/vue源码之双向绑定原理/","excerpt":"","text":"了解Object.defineProperty了解过vue绑定原理的人都知道。双向绑定的原理是利用数据劫持结合发布者–订阅者模式的方式，通过Object.defineProperty来劫持各个属性setter、getter，在数据发生变动时发布消息给订阅者，触发响应的回调函数。简单了解一下Object.defineProperty，具体用法查看MDN 手动实现简单的绑定123456789101112var obj = &#123;&#125;;Object.defineProperty(obj, &apos;name&apos;, &#123; get: function(val) &#123; console.log(&apos;获取值被修改的值&apos;) return val; &#125;, set: function (newVal) &#123; console.log(&apos;我被设置了&apos;+ newVal) &#125;&#125;)obj.name = &apos;隔壁老王&apos;;//在给obj设置name属性的时候，触发了set这个方法var val = obj.name;//在得到obj的name属性，会触发get方法 这样我们就可以在get和set中触发其他函数，从而来实现监听数据变动的目的。根据以上描述，我们可以实现一个简单的双向绑定：代码如下 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;bindDemo&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;iptVal&quot;&gt; &lt;script&gt; var bindDemo = document.getElementById(&apos;bindDemo&apos;) var iptVal = document.getElementById(&apos;iptVal&apos;) var obj = &#123;&#125; Object.defineProperty(obj, &apos;name&apos;,&#123; get:function()&#123; return val &#125;, set:function(newVal)&#123; // 给对象设置值得时候会触发该方法 console.log(newVal) bindDemo.innerHTML = newVal &#125; &#125;) iptVal.addEventListener(&apos;input&apos;, function(e)&#123; obj.name = e.target.value &#125;) obj.name = &apos;老李&apos; // 给obj设置了name属性从而触发了set方法 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样就实现了一个简单的双向绑定。 vue双向绑定原理图镇楼：···flow #由于渲染问题，请自行将 · 替换为 `//定义部分st=&gt;start: Start:&gt;http://www.google.com[blank]e=&gt;end:&gt;http://www.google.comop1=&gt;operation: My Operationsub1=&gt;subroutine: My Subroutinecond=&gt;condition: Yes or No?:&gt;http://www.google.comio=&gt;inputoutput: catch something… //判断和位置控制st-&gt;op1-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op1···…mermaidgraph LR MVVM – 劫持监听所有属性 –&gt; Observer Observer –通知变化 –&gt; dep{Dep} dep{Dep} –通知变化 –&gt;Watcher Watcher –添加订阅者 –&gt;dep{Dep} MVVM -- 解析指令 --&gt; compile compile --订阅数据变化 --&gt;Watcher compile --初始化视图 --&gt; update(updater) Watcher --更新视图 --&gt; update(updater) …原理图解析：1、observer的作用：通过object.defineProperty()循环劫持vue中data的所有属性值，从而利用get和set来通知订阅者Dep，从而来更新视图。2、指令解析：我们都知道在vue中实现双向绑定的常用指令有：v-model，v-text,双花括号等等。也就是说在渲染html节点时，碰到这些指令的时候会进行指令解析。每碰到一个指令，就会在Dep中增加一个订阅者，这个订阅者只是更新自己指令对应的数据。每当set方法触发，就会循环触发Dep中对应的订阅者。实现一个observer监听器，通过递归的方法遍历所有的对象以及对象中的对象也就是属性值，从而来监听所有的属性 所有对象的属性劫持12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;bindDemo&quot;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;iptVal&quot;&gt; &lt;script&gt; var bindDemo = document.getElementById(&apos;bindDemo&apos;) var iptVal = document.getElementById(&apos;iptVal&apos;) function defineReactive(obj,key,val)&#123; observe(val); Object.defineProperty(obj, key, &#123; get: function()&#123; //在这里进行依赖收集 return val &#125;, set: function(newVal)&#123; if(newVal === val) return console.log(newVal) iptVal.value = newVal bindDemo.innerHTML = newVal &#125; &#125;) &#125; /**通过遍历所有属性的方式对这个obj进行defineReactive的处理***/ function observe (obj) &#123; debugger if(!obj || (typeof obj !==&apos;object&apos;)) &#123; return &#125; Object.keys(obj).forEach(function(key)&#123; defineReactive(obj, key, obj[key]); &#125;) &#125; var dataList =&#123; person:&#123; name: &apos;老王&apos;, age: &apos;17&apos; &#125; &#125; observe(dataList) iptVal.addEventListener(&apos;input&apos;, function(e) &#123; // 给obj的name属性赋值，进而触发该属性的set方法 dataList.person.name = e.target.value; &#125;); dataList.person.name = &apos;老李&apos; // 这样就实现了所有的对象以及属性的监听 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 以上代码实现了对象属性值的劫持，下面通过解析指令实现对view和model的绑定 指令解析12345678910111213141516171819202122232425262728293031323334 /** 解析指令，实现对view和model的绑定*/ compile(root,vm)&#123; // var _this = this var nodes =root.children // 节点类型为元素 for (let i = 0; i &lt; nodes.length; i++) &#123; var node = nodes[i] if (node.children.length) &#123; vm.compile(node,vm) &#125; if (node.hasAttribute(&apos;v-click&apos;)) &#123; node.onclick=(function(e)&#123; var attrval = nodes[i].getAttribute(&apos;v-click&apos;) console.log(attrval) return vm.methods[attrval].bind(vm.data) &#125;)() &#125; if (node.hasAttribute(&apos;v-model&apos;)&amp;&amp;(node.tagName == &apos;INPUT&apos; || node.tagName == &apos;TEXTAREA&apos; )) &#123; node.addEventListener(&apos;input&apos;,(function(e)&#123; var name= node.getAttribute(&apos;v-model&apos;) new watcher(vm, node, name, &apos;value&apos;) return function()&#123; vm.data[name] = nodes[e].value &#125; &#125;)(i)) &#125; if (node.hasAttribute(&apos;v-bind&apos;)) &#123; var name = node.getAttribute(&apos;v-bind&apos;) new watcher(vm, node, name, &apos;innerHTML&apos;) &#125; &#125; &#125;&#125; 订阅器创建一个可以容纳订阅者的消息订阅器Dep，订阅器Dep主要负责收集订阅者，然后在属性变化的时候执行对应订阅者的更新函数。所以显然订阅器需要有一个容器，这个容器就是list，将上面的Observer稍微改造下，植入消息订阅器： 123456789101112131415161718192021222324252627282930313233343536 defineReactive (obj,key,val)&#123; const dep = new Dep() Object.defineProperty(obj,key,&#123; enumerable: true, configurable: true, get:function()&#123; /*****进行依赖收集（需要一个方法）将Dep.target（即当前的Watcher对象存入dep的subs中）******/ if (Dep.target) &#123; dep.addsub(Dep.target) &#125; return val &#125;, set:function(newVal)&#123; if (newVal === val) return val = newVal dep.notify() &#125; &#125;)&#125;// 构造订阅者Depclass Dep &#123; constructor()&#123; /* 用来存放Watcher对象的数组 */ this.subs = [] &#125; /*在subs中添加一个watch对象*/ addsub(sub)&#123; this.subs.push(sub) &#125; /*通知所有对象更新视图*/ notify()&#123; this.subs.forEach((sub) =&gt;&#123; sub.update() &#125;) &#125;&#125; 从代码上看，我们将订阅器Dep添加一个订阅者设计在getter里面，这是为了让Watcher初始化进行触发，因此需要判断是否要添加订阅者，至于具体设计方案，下文会详细说明的。在setter函数里面，如果数据变化，就会去通知所有订阅者，订阅者们就会去执行对应的更新的函数。到此为止，一个比较完整Observer已经实现了，接下来我们开始设计Watcher。 watch我们知道，监听器Observer是在get函数执行了添加订阅者Wather的操作的，所以我们只要在订阅者Watcher初始化的时候触发对应的get函数去执行添加订阅者操作即可。而触发get函数只要获取对应的属性值就可以了。核心原因就是因为我们使用了Object.defineProperty( )进行数据监听。 1234567891011121314151617181920 class watcher&#123; constructor(vm, node, name, type)&#123; /* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */ Dep.target = this this.name = name //指令对应的值 this.node = node //节点 this.vm = vm //指令所属Vue this.type = type //绑定的属性值，本例为InnerHTML this.update() Dep.target = null &#125; update() &#123; this.get() // this.node.nodeValue = this.value this.node[this.type] = this.value &#125; get() &#123; this.value = this.vm.data[this.name] &#125;&#125; 结语到此为止，vue双向绑定的原理基本实现。这篇文章只是粗略的的概述了一下vue双向绑定的原理。本文的完整代码请参考这里。如果你觉得还行的话点个赞就行。如果发现有什么不足的话，欢迎指出。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"探究promise原理","slug":"探究promise原理","date":"2019-02-27T14:55:39.116Z","updated":"2019-03-02T04:10:22.349Z","comments":true,"path":"2019/02/27/探究promise原理/","link":"","permalink":"http://yoursite.com/2019/02/27/探究promise原理/","excerpt":"","text":"什么是promisePromise是JS异步编程中的重要概念，异步抽象处理对象，是目前比较流行Javascript异步编程解决方案之一 常用的异步编程方案 回调函数 事件监听 发布/订阅（之后文章了解） promise promise标准 1.Promise 规范有很多，如Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+。ES6 中采用了 Promise/A+ 规范，这里了解的也是Promise/A+ 的实现原理。 2.Promise标准解读 在之前一章有了解过promise的状态变化以及基本的使用方法，所以直接略过，直奔主题，了解promise的实现过程 从里到外解剖promise手动实现promise，需要先了解promise的执行流程以及在流程中调用的方法？ 流程分析12345678graph LRA[new promise] --&gt;B(pendding)B --fulfilled --&gt; C(resolve) B--rejected --&gt; D(reject)C --&gt; E(onFulfilled)D --&gt; F(onRejected )E --&gt;G(promise)F --&gt;G new一个promise实例，瞬间执行(初始状态)，状态为pending new Promise接收一个excutor执行函数，excutor携带连个函数类型参数resolve和 reject 1234const promise = new promise((resolve, reject) =&gt;&#123; // 异步处理 // 处理结束后、调用resolve 或 reject&#125;) 调用resolve，状态由pending –&gt; fulfiled。调用reject，状态由pending –&gt; rejected。注意：一旦状态更改就不能再次发生变化。 123456789101112131415161718192021222324252627282930313233343536373839function Promise()&#123; let that = self // 缓存当前实例 that.status = &apos;pending&apos; // 初始状态 that.data = undifined //成功时的返回值 that.reason = undifined //保存失败的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数，可能有多个 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数，可能有多个 // 成功时调用的方法 function resolve(value) &#123; if(self.status === &apos;pending&apos;) &#123; self.status = &apos;resolved&apos;; self.data = value; for(var i = 0; i &lt; self.onFulfilledCallbacks.length; i++) &#123; self.onResolvedCallback[i](value); &#125; &#125; &#125; // 失败时调用的方法 function reject(reason) &#123; if(self.status === &apos;pending&apos;) &#123; self.status = &apos;rejected&apos;; self.data = reason; for(var i = 0; i &lt; self.onRejectedCallback.length; i++) &#123; self.onRejectedCallback[i](reason); &#125; &#125; &#125; // executor自执行函数接收的第二个参数为reject函数 //且reject函数在promise对象状态变为rejected时或executor抛出异常时触发 try &#123; executor(resolve, reject); &#125; catch (e)&#123; reject(e); &#125;&#125;Promise.prototype.then = function (onResolve, onReject) &#123; this.onResolvedCallback.push(onResolve); this.onRejectedCallback.push(onReject);&#125;; 兴高采烈，试试深浅~~~~妈呀好像并没有什么卵用？仔细一看，虎躯一震？当我们在调用then回调之前，resolve已经执行结束了？ 用高大上的语言来表达：2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行. 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 总结一下就是需要将promise的resolve和reject异步执行 修改一下，可以利用setTimeout机制，将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成. 12345678910111213141516171819202122232425添加个异步// 成功时调用的方法 function resolve(value) &#123; setTimeout(function () &#123; if(self.status === &apos;pending&apos;) &#123; that.status = &apos;resolved&apos;; that.data = value; for(var i = 0; i &lt; self.onFulfilledCallbacks.length; i++) &#123; self.onResolvedCallback[i](value); &#125; &#125; &#125;,0) &#125; // 失败时调用的方法 function reject(reason) &#123; setTimeout(function () &#123; if(self.status === &apos;pending&apos;) &#123; that.status = &apos;rejected&apos;; that.data = reason; for(var i = 0; i &lt; self.onRejectedCallback.length; i++) &#123; self.onRejectedCallback[i](reason); &#125; &#125; &#125;,0) &#125; 总结：1.executor函数作为实参在创建Promise对象时传入Promise构造函数。2.resolve和reject函数作为实参传入executor函数。3.value作为实参传入resolve和reject函数。4.promise的resolve和reject需要异步执行 then Promise/A+ 规范中规定then方法用来注册promise对象状态改变时的回调，且返回一个新的promise对象。而上述代码并没有满足这个规范，那么~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * resolve中的值几种情况： * 1.普通值 * 2.promise对象 * 3.thenable对象/函数 *//** * 对resolve 进行改造增强 针对resolve中不同值情况 进行处理 * @param &#123;promise&#125; promise2 promise1.then方法返回的新的promise对象 * @param &#123;[type]&#125; x promise1中onFulfilled的返回值 * @param &#123;[type]&#125; resolve promise2的resolve方法 * @param &#123;[type]&#125; reject promise2的reject方法 */function resolvePromise(promise2, x, resolve, reject) &#123; var then var thenCalledOrThrow = false if (promise2 === x) &#123; return reject(new TypeError(&apos;Chaining cycle detected for promise!&apos;)) &#125; if (x instanceof Promise) &#123; if (x.status === &apos;pending&apos;) &#123; //because x could resolved by a Promise Object x.then(function(v) &#123; resolvePromise(promise2, v, resolve, reject) &#125;, reject) &#125; else &#123; //but if it is resolved, it will never resolved by a Promise Object but a static value; x.then(resolve, reject) &#125; return &#125; if ((x !== null) &amp;&amp; ((typeof x === &apos;object&apos;) || (typeof x === &apos;function&apos;))) &#123; try &#123; then = x.then //because x.then could be a getter if (typeof then === &apos;function&apos;) &#123; then.call(x, function rs(y) &#123; if (thenCalledOrThrow) return thenCalledOrThrow = true return resolvePromise(promise2, y, resolve, reject) &#125;, function rj(r) &#123; if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(r) &#125;) &#125; else &#123; resolve(x) &#125; &#125; catch (e) &#123; if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(e) &#125; &#125; else &#123; resolve(x) &#125;&#125;Promise.prototype.then = function (onResolved, onRejected) &#123; var self = this var promise2 onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(v) &#123; return v &#125; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(r) &#123; throw r &#125; //promise对象当前状态为resolved if(self.status === &apos;resolved&apos;) &#123; return promise2 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; // 异步执行onResolved try &#123; var x = onResolved(self.data) resolvePromise(promise2, x, resolve, reject) &#125; catch (reason) &#123; reject(reason) &#125; &#125;) &#125;) &#125; //promise对象当前状态为rejected if (self.status === &apos;rejected&apos;) &#123; return promise2 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; // 异步执行onRejected try &#123; var x = onRejected(self.data) resolvePromise(promise2, x, resolve, reject) &#125; catch (reason) &#123; reject(reason) &#125; &#125;) &#125;) &#125; //promise对象当前状态为pending //此时并不能确定调用onResolved还是onRejected，需要等当前Promise状态确定。 //所以需要将callBack放入promise1的回调数组中 if (self.status === &apos;pending&apos;) &#123; return promise2 = new Promise(function(resolve, reject) &#123; self.onResolvedCallback.push(function(value) &#123; try &#123; var x = onResolved(value) resolvePromise(promise2, x, resolve, reject) &#125; catch (r) &#123; reject(r) &#125; &#125;) self.onRejectedCallback.push(function(reason) &#123; try &#123; var x = onRejected(reason) resolvePromise(promise2, x, resolve, reject) &#125; catch (r) &#123; reject(r) &#125; &#125;) &#125;) &#125;&#125;; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274var Promise = (function() &#123; function Promise(resolver) &#123; if (typeof resolver !== &apos;function&apos;) &#123; //resolver必须是函数 throw new TypeError(&apos;Promise resolver &apos; + resolver + &apos; is not a function&apos;) &#125; if (!(this instanceof Promise)) return new Promise(resolver) var self = this //保存this self.callbacks = [] //保存onResolve和onReject函数集合 self.status = &apos;pending&apos; //当前状态 function resolve(value) &#123; setTimeout(function() &#123; //异步调用 if (self.status !== &apos;pending&apos;) &#123; return &#125; self.status = &apos;resolved&apos; //修改状态 self.data = value for (var i = 0; i &lt; self.callbacks.length; i++) &#123; self.callbacks[i].onResolved(value) &#125; &#125;) &#125; function reject(reason) &#123; setTimeout(function()&#123; //异步调用 if (self.status !== &apos;pending&apos;) &#123; return &#125; self.status = &apos;rejected&apos; //修改状态 self.data = reason for (var i = 0; i &lt; self.callbacks.length; i++) &#123; self.callbacks[i].onRejected(reason) &#125; &#125;) &#125; try&#123; resolver(resolve, reject) //执行resolver函数 &#125; catch(e) &#123; reject(e) &#125; &#125; function resolvePromise(promise, x, resolve, reject) &#123; var then var thenCalledOrThrow = false if (promise === x) &#123; return reject(new TypeError(&apos;Chaining cycle detected for promise!&apos;)) &#125; if ((x !== null) &amp;&amp; ((typeof x === &apos;object&apos;) || (typeof x === &apos;function&apos;))) &#123; try &#123; then = x.then if (typeof then === &apos;function&apos;) &#123; then.call(x, function rs(y) &#123; if (thenCalledOrThrow) return thenCalledOrThrow = true return resolvePromise(promise, y, resolve, reject) &#125;, function rj(r) &#123; if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(r) &#125;) &#125; else &#123; return resolve(x) &#125; &#125; catch(e) &#123; if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(e) &#125; &#125; else &#123; return resolve(x) &#125; &#125; Promise.prototype.then = function(onResolved, onRejected) &#123; //健壮性处理，处理点击穿透 onResolved = typeof onResolved === &apos;function&apos; ? onResolved : function(v)&#123;return v&#125; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : function(r)&#123;throw r&#125; var self = this var promise2 //promise状态为resolved if (self.status === &apos;resolved&apos;) &#123; return promise2 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; try &#123; //调用then方法的onResolved回调 var x = onResolved(self.data) //根据x的值修改promise2的状态 resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; //promise2状态变为rejected return reject(e) &#125; &#125;) &#125;) &#125; //promise状态为rejected if (self.status === &apos;rejected&apos;) &#123; return promise2 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; try &#123; //调用then方法的onReject回调 var x = onRejected(self.data) //根据x的值修改promise2的状态 resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; //promise2状态变为rejected return reject(e) &#125; &#125;) &#125;) &#125; //promise状态为pending //需要等待promise的状态改变 if (self.status === &apos;pending&apos;) &#123; return promise2 = new Promise(function(resolve, reject) &#123; self.callbacks.push(&#123; onResolved: function(value) &#123; try &#123; //调用then方法的onResolved回调 var x = onResolved(value) //根据x的值修改promise2的状态 resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; //promise2状态变为rejected return reject(e) &#125; &#125;, onRejected: function(reason) &#123; try &#123; //调用then方法的onResolved回调 var x = onRejected(reason) //根据x的值修改promise2的状态 resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; //promise2状态变为rejected return reject(e) &#125; &#125; &#125;) &#125;) &#125; &#125; //获取当前Promise传递的值 Promise.prototype.valueOf = function() &#123; return this.data &#125; //由then方法实现catch方法 Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected) &#125; //finally方法 Promise.prototype.finally = function(fn) &#123; return this.then(function(v)&#123; setTimeout(fn) return v &#125;, function(r)&#123; setTimeout(fn) throw r &#125;) &#125; Promise.prototype.spread = function(fn, onRejected) &#123; return this.then(function(values) &#123; return fn.apply(null, values) &#125;, onRejected) &#125; Promise.prototype.inject = function(fn, onRejected) &#123; return this.then(function(v) &#123; return fn.apply(null, fn.toString().match(/\\((.*?)\\)/)[1].split(&apos;,&apos;).map(function(key)&#123; return v[key]; &#125;)) &#125;, onRejected) &#125; Promise.prototype.delay = function(duration) &#123; return this.then(function(value) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; resolve(value) &#125;, duration) &#125;) &#125;, function(reason) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; reject(reason) &#125;, duration) &#125;) &#125;) &#125; Promise.all = function(promises) &#123; return new Promise(function(resolve, reject) &#123; var resolvedCounter = 0 var promiseNum = promises.length var resolvedValues = new Array(promiseNum) for (var i = 0; i &lt; promiseNum; i++) &#123; (function(i) &#123; Promise.resolve(promises[i]).then(function(value) &#123; resolvedCounter++ resolvedValues[i] = value if (resolvedCounter == promiseNum) &#123; return resolve(resolvedValues) &#125; &#125;, function(reason) &#123; return reject(reason) &#125;) &#125;)(i) &#125; &#125;) &#125; Promise.race = function(promises) &#123; return new Promise(function(resolve, reject) &#123; for (var i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i]).then(function(value) &#123; return resolve(value) &#125;, function(reason) &#123; return reject(reason) &#125;) &#125; &#125;) &#125; Promise.resolve = function(value) &#123; var promise = new Promise(function(resolve, reject) &#123; resolvePromise(promise, value, resolve, reject) &#125;) return promise &#125; Promise.reject = function(reason) &#123; return new Promise(function(resolve, reject) &#123; reject(reason) &#125;) &#125; Promise.fcall = function(fn)&#123; // 虽然fn可以接收到上一层then里传来的参数，但是其实是undefined，所以跟没有是一样的，因为resolve没参数啊 return Promise.resolve().then(fn) &#125; Promise.done = Promise.stop = function()&#123; return new Promise(function()&#123;&#125;) &#125; Promise.deferred = Promise.defer = function() &#123; var dfd = &#123;&#125; dfd.promise = new Promise(function(resolve, reject) &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd &#125; try &#123; // CommonJS compliance module.exports = Promise &#125; catch(e) &#123;&#125; return Promise&#125;)() 参考文章：Promise原理讲解 &amp;&amp; 实现一个Promise对象 (遵循Promise/A+规范)Promise原理与实现","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"快速认识promise","slug":"快速使用promise","date":"2019-02-26T14:45:55.691Z","updated":"2019-03-02T04:10:16.963Z","comments":true,"path":"2019/02/26/快速使用promise/","link":"","permalink":"http://yoursite.com/2019/02/26/快速使用promise/","excerpt":"","text":"1、为什么要用Promise？（es6）当我们使用js的异步调用时通常喜欢使用回调函数，这样代码便于理解。但是当回调嵌套的时候会造成代码混乱，不好梳理，例如：12345678910function(arg1, function()&#123; function(arg2, function()&#123; function(arg3, fucntion()&#123; ...... &#125; ) &#125;) &#125;) 像上面代码，无穷嵌套会造成代码混乱。而Promise的最大好处就是避免‘无穷的回调噩梦’，上述代码用promise处理： 123var p = new Promise(function(resolve,reject&#123;&#125;).then(function(data)&#123;&#125;).then(function()&#123;&#125;) 这是Promise的基本用法Promise接收一个回调函数，回调函数接收两个参数，resolve（promise的状态从pending变为了fulfiled,成功时调用）、reject（promise的状态从pending变为了rejected,失败时调用），这两个都是函数，表示成功和失败的处理函数。then中接收的是上一次回调返回的结果 2、promise.prototype.then()123456789101112let promise = new Promise(function(resolve,reject)&#123;console.log(&quot;promise&quot;);resolve();&#125;);setTimeout(function()&#123;console.log(&quot;setTimeout&quot;);&#125;,0)promise.then(function()&#123;console.log(&quot;resolved&quot;);&#125;)console.log(&quot;hi&quot;);//promise hi resolved setTimeout promise是创建之后立即执行，then方法指定的脚本在当前所有的同步任务完成之后再执行，setTimeout是在下一轮“时间循环”开始时执行，then在本轮时间循环结束时还行 3、promise.prototype.catch()1234567891011let promise = new Promise(function(resolve,reject)&#123;reject();&#125;);promise.then(function()&#123;console.log(&quot;resolved&quot;);&#125;).catch(function()&#123;console.log(&quot;catch the reject&quot;)&#125;)输出 catch the reject 4、promise的方法有：promise.resolve()promise.reject()promise.all()promise.race()","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}
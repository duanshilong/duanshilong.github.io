{"meta":{"title":"dsl-blog","subtitle":null,"description":null,"author":"Hubery","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"快速认识promise","slug":"快速使用promise","date":"2019-02-26T14:45:55.691Z","updated":"2019-02-26T15:22:07.664Z","comments":true,"path":"2019/02/26/快速使用promise/","link":"","permalink":"http://yoursite.com/2019/02/26/快速使用promise/","excerpt":"","text":"1、为什么要用Promise？（es6）当我们使用js的异步调用时通常喜欢使用回调函数，这样代码便于理解。但是当回调嵌套的时候会造成代码混乱，不好梳理，例如：12345678910function(arg1, function()&#123; function(arg2, function()&#123; function(arg3, fucntion()&#123; ...... &#125; ) &#125;) &#125;) 像上面代码，无穷嵌套会造成代码混乱。而Promise的最大好处就是避免‘无穷的回调噩梦’，上述代码用promise处理： 123var p = new Promise(function(resolve,reject&#123;&#125;).then(function(data)&#123;&#125;).then(function()&#123;&#125;) 这是Promise的基本用法Promise接收一个回调函数，回调函数接收两个参数，resolve（promise的状态从pending变为了fulfiled,成功时调用）、reject（promise的状态从pending变为了rejected,失败时调用），这两个都是函数，表示成功和失败的处理函数。then中接收的是上一次回调返回的结果 2、promise.prototype.then()123456789101112let promise = new Promise(function(resolve,reject)&#123;console.log(&quot;promise&quot;);resolve();&#125;);setTimeout(function()&#123;console.log(&quot;setTimeout&quot;);&#125;,0)promise.then(function()&#123;console.log(&quot;resolved&quot;);&#125;)console.log(&quot;hi&quot;);//promise hi resolved setTimeout promise是创建之后立即执行，then方法指定的脚本在当前所有的同步任务完成之后再执行，setTimeout是在下一轮“时间循环”开始时执行，then在本轮时间循环结束时还行 3、promise.prototype.catch()1234567891011let promise = new Promise(function(resolve,reject)&#123;reject();&#125;);promise.then(function()&#123;console.log(&quot;resolved&quot;);&#125;).catch(function()&#123;console.log(&quot;catch the reject&quot;)&#125;)输出 catch the reject 4、promise的方法有：promise.resolve()promise.reject()promise.all()promise.race()","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}